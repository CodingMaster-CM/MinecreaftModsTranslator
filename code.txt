import os
import sys
import json
import re
import shutil
import zipfile
import tempfile
import requests
from pathlib import Path
from urllib.parse import quote
from tqdm import tqdm
import platform
import subprocess

# Try to import TOML parser (Python 3.11+ has tomllib, older needs tomli)
try:
    import tomllib as toml
except ImportError:
    try:
        import tomli as toml
    except ImportError:
        toml = None

# =========================
# Translation cache
# =========================
translation_cache = {}

# =========================
# Multi-language terminology (fallback)
# =========================
TERMINOLOGY = {
    "zh_tw": {
        "Copper": "ÈäÖ", "Aluminum": "ÈãÅ", "Aluminium": "ÈãÅ", "Lead": "Èâõ", "Silver": "ÈäÄ",
        "Nickel": "Èé≥", "Uranium": "Èàæ", "Constantan": "Â∫∑ÈäÖ", "Electrum": "Áê•ÁèÄÈáë", "Steel": "Èãº",
        "Iron": "Èêµ", "Gold": "Èáë", "Tin": "Èå´", "Zinc": "ÈãÖ", "Brass": "ÈªÉÈäÖ", "Ingot": "Èå†",
        "Ore": "Á§¶", "Block": "ÊñπÂ°ä", "Plate": "Êùø", "Dust": "Á≤â", "Nugget": "Á≤í", "Stick": "Ê£í",
        "Rod": "Ê°ø", "Tool": "Â∑•ÂÖ∑", "Machine": "Ê©üÂô®", "Generator": "ÁôºÈõªÊ©ü", "Engineer": "Â∑•Á®ãÂ∏´",
        "Workbench": "Â∑•‰ΩúÂè∞", "Furnace": "ÁÜîÁàê", "Crucible": "Âù©Â†ù", "Conveyor": "Ëº∏ÈÄÅÂ∏∂",
        "Pump": "Ê≥µ", "Tank": "ÂÑ≤ÁΩê", "Silo": "Á≠íÂÄâ", "Barrel": "Ê°∂", "Bucket": "Ê°∂",
        "Helmet": "È†≠Áõî", "Chestplate": "ËÉ∏Áî≤", "Leggings": "Ë≠∑ËÖø", "Boots": "Èù¥Â≠ê",
        "Fluid": "ÊµÅÈ´î", "Item": "Áâ©ÂìÅ", "Wire": "ÈõªÁ∑ö", "Cable": "ÈõªÁ∫ú", "Pipe": "ÁÆ°",
        "Manual": "ÊâãÂÜä", "Pickaxe": "Èé¨", "Shovel": "Èèü", "Axe": "Êñß", "Hoe": "Èã§", "Sword": "Âäç"
    },
    "zh_cn": {
        "Copper": "Èìú", "Aluminum": "Èìù", "Aluminium": "Èìù", "Lead": "ÈìÖ", "Silver": "Èì∂",
        "Nickel": "Èïç", "Uranium": "ÈìÄ", "Constantan": "Â∫∑Èìú", "Electrum": "Áê•ÁèÄÈáë", "Steel": "Èí¢",
        "Iron": "ÈìÅ", "Gold": "Èáë", "Tin": "Èî°", "Zinc": "Èîå", "Brass": "ÈªÑÈìú", "Ingot": "Èî≠",
        "Ore": "ÁüøÁü≥", "Block": "ÊñπÂùó", "Plate": "Êùø", "Dust": "Á≤â", "Nugget": "Á≤í", "Stick": "Ê£í",
        "Rod": "ÊùÜ", "Tool": "Â∑•ÂÖ∑", "Machine": "Êú∫Âô®", "Generator": "ÂèëÁîµÊú∫", "Engineer": "Â∑•Á®ãÂ∏à",
        "Workbench": "Â∑•‰ΩúÂè∞", "Furnace": "ÁÜîÁÇâ", "Crucible": "Âù©Âüö", "Conveyor": "‰º†ÈÄÅÂ∏¶",
        "Pump": "Ê≥µ", "Tank": "ÂÇ®ÁΩê", "Silo": "Á≠í‰ªì", "Barrel": "Ê°∂", "Bucket": "Ê°∂",
        "Helmet": "Â§¥Áõî", "Chestplate": "ËÉ∏Áî≤", "Leggings": "Êä§ËÖø", "Boots": "Èù¥Â≠ê",
        "Fluid": "ÊµÅ‰Ωì", "Item": "Áâ©ÂìÅ", "Wire": "ÁîµÁ∫ø", "Cable": "ÁîµÁºÜ", "Pipe": "ÁÆ°",
        "Manual": "ÊâãÂÜå", "Pickaxe": "Èïê", "Shovel": "Èì≤", "Axe": "Êñß", "Hoe": "ÈîÑ", "Sword": "Ââë"
    },
    "ja_jp": {
        "Copper": "ÈäÖ", "Aluminum": "„Ç¢„É´„Éü„Éã„Ç¶„É†", "Lead": "Èâõ", "Silver": "ÈäÄ", "Nickel": "„Éã„ÉÉ„Ç±„É´",
        "Steel": "Èãº", "Iron": "ÈâÑ", "Gold": "Èáë", "Ingot": "„Ç§„É≥„Ç¥„ÉÉ„Éà", "Ore": "Èâ±Áü≥",
        "Block": "„Éñ„É≠„ÉÉ„ÇØ", "Tool": "„ÉÑ„Éº„É´", "Machine": "„Éû„Ç∑„É≥", "Generator": "Áô∫ÈõªÊ©ü",
        "Workbench": "‰ΩúÊ•≠Âè∞", "Furnace": "ÁÇâ", "Pump": "„Éù„É≥„Éó", "Tank": "„Çø„É≥„ÇØ",
        "Helmet": "„Éò„É´„É°„ÉÉ„Éà", "Chestplate": "„ÉÅ„Çß„Çπ„Éà„Éó„É¨„Éº„Éà", "Leggings": "„É¨„ÇÆ„É≥„Çπ", "Boots": "„Éñ„Éº„ÉÑ",
        "Item": "„Ç¢„Ç§„ÉÜ„É†", "Wire": "„ÉØ„Ç§„É§„Éº", "Manual": "„Éû„Éã„É•„Ç¢„É´", "Pickaxe": "„ÉÑ„É´„Éè„Ç∑",
        "Shovel": "„Ç∑„É£„Éô„É´", "Axe": "Êñß", "Hoe": "„ÇØ„ÉØ", "Sword": "Ââ£"
    },
    "ko_kr": {
        "Copper": "Íµ¨Î¶¨", "Aluminum": "ÏïåÎ£®ÎØ∏ÎäÑ", "Lead": "ÎÇ©", "Silver": "ÏùÄ", "Nickel": "ÎãàÏºà",
        "Steel": "Í∞ïÏ≤†", "Iron": "Ï≤†", "Gold": "Í∏à", "Ingot": "Ï£ºÍ¥¥", "Ore": "Í¥ëÏÑù",
        "Block": "Î∏îÎ°ù", "Tool": "ÎèÑÍµ¨", "Machine": "Í∏∞Í≥Ñ", "Generator": "Î∞úÏ†ÑÍ∏∞",
        "Workbench": "ÏûëÏóÖÎåÄ", "Furnace": "ÌôîÎ°ú", "Pump": "ÌéåÌîÑ", "Tank": "ÌÉ±ÌÅ¨",
        "Helmet": "Ìà¨Íµ¨", "Chestplate": "ÌùâÍ∞ë", "Leggings": "Î∞îÏßÄ", "Boots": "Î∂ÄÏ∏†",
        "Item": "ÏïÑÏù¥ÌÖú", "Wire": "Ï†ÑÏÑ†", "Manual": "Îß§Îâ¥Ïñº", "Pickaxe": "Í≥°Í¥≠Ïù¥",
        "Shovel": "ÏÇΩ", "Axe": "ÎèÑÎÅº", "Hoe": "Í¥≠Ïù¥", "Sword": "Í≤Ä"
    },
    "es_es": {
        "Copper": "Cobre", "Aluminum": "Aluminio", "Lead": "Plomo", "Silver": "Plata", "Nickel": "N√≠quel",
        "Steel": "Acero", "Iron": "Hierro", "Gold": "Oro", "Ingot": "Lingote", "Ore": "Mena",
        "Block": "Bloque", "Tool": "Herramienta", "Machine": "M√°quina", "Generator": "Generador",
        "Workbench": "Banco de trabajo", "Furnace": "Horno", "Pump": "Bomba", "Tank": "Tanque",
        "Helmet": "Casco", "Chestplate": "Peto", "Leggings": "Grebas", "Boots": "Botas",
        "Item": "Objeto", "Manual": "Manual", "Pickaxe": "Pico", "Shovel": "Pala", "Axe": "Hacha",
        "Hoe": "Azada", "Sword": "Espada"
    },
    "ru_ru": {
        "Copper": "–ú–µ–¥—å", "Aluminum": "–ê–ª—é–º–∏–Ω–∏–π", "Lead": "–°–≤–∏–Ω–µ—Ü", "Silver": "–°–µ—Ä–µ–±—Ä–æ", "Nickel": "–ù–∏–∫–µ–ª—å",
        "Steel": "–°—Ç–∞–ª—å", "Iron": "–ñ–µ–ª–µ–∑–æ", "Gold": "–ó–æ–ª–æ—Ç–æ", "Ingot": "–°–ª–∏—Ç–æ–∫", "Ore": "–†—É–¥–∞",
        "Block": "–ë–ª–æ–∫", "Tool": "–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç", "Machine": "–ú–∞—à–∏–Ω–∞", "Generator": "–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä",
        "Workbench": "–í–µ—Ä—Å—Ç–∞–∫", "Furnace": "–ü–µ—á—å", "Pump": "–ù–∞—Å–æ—Å", "Tank": "–†–µ–∑–µ—Ä–≤—É–∞—Ä",
        "Helmet": "–®–ª–µ–º", "Chestplate": "–ù–∞–≥—Ä—É–¥–Ω–∏–∫", "Leggings": "–ü–æ–Ω–æ–∂–∏", "Boots": "–°–∞–ø–æ–≥–∏",
        "Item": "–ü—Ä–µ–¥–º–µ—Ç", "Wire": "–ü—Ä–æ–≤–æ–¥", "Manual": "–†—É–∫–æ–≤–æ–¥—Å—Ç–≤–æ", "Pickaxe": "–ö–∏—Ä–∫–∞",
        "Shovel": "–õ–æ–ø–∞—Ç–∞", "Axe": "–¢–æ–ø–æ—Ä", "Hoe": "–ú–æ—Ç—ã–≥–∞", "Sword": "–ú–µ—á"
    }
}

LANGUAGE_INFO = {
    "zh_tw": {"name": "ÁπÅÈ´î‰∏≠Êñá", "code": "zh_tw", "region": "Taiwan"},
    "zh_cn": {"name": "ÁÆÄ‰Ωì‰∏≠Êñá", "code": "zh_cn", "region": "China"},
    "ja_jp": {"name": "Êó•Êú¨Ë™û", "code": "ja_jp", "region": "Japan"},
    "ko_kr": {"name": "ÌïúÍµ≠Ïñ¥", "code": "ko_kr", "region": "Korea"},
    "es_es": {"name": "Espa√±ol", "code": "es_es", "region": "Spain"},
    "ru_ru": {"name": "–†—É—Å—Å–∫–∏–π", "code": "ru_ru", "region": "Russia"},
    "en_us": {"name": "English (US)", "code": "en_us", "region": "United States"},
    "de_de": {"name": "Deutsch", "code": "de_de", "region": "Germany"},
    "fr_fr": {"name": "Fran√ßais", "code": "fr_fr", "region": "France"},
    "it_it": {"name": "Italiano", "code": "it_it", "region": "Italy"}
}

# =========================
# Full UI translations for ALL UI languages
# =========================
UI_STRINGS = {
    "en_us": {
        "banner_title": "‚ö° Minecraft Mod Language Translator (Translation only) ‚ö°",
        "desc": (
            "This tool:\n"
            "  ‚Ä¢ Scans all .jar mods in a folder\n"
            "  ‚Ä¢ If target language file is missing, copies en_us.json and translates\n"
            "  ‚Ä¢ Creates .backup for every modified jar\n"
        ),
        "choose_ui": "üåê Choose UI language",
        "choose_target": "üåç Choose target language file to generate",
        "choose_range": "‚ùì Choose (1-{n}, default {d}): ",
        "choose_invalid": "‚ùå Invalid input. Please enter a valid number.",
        "need_packages": "‚ö†Ô∏è Missing Python packages:",
        "install_confirm": "‚úÖ Install them automatically? (Y/N, default Y): ",
        "install_fail": "‚ùå Failed to install packages:",
        "install_hint": "üí° Manual install: pip install --user requests tqdm tomli",
        "backup_menu": "üíæ Backup option",
        "backup_keep": "1) Keep all backups (keep)",
        "backup_delete_success": "2) Delete backups only when success (delete_success)",
        "backup_delete_all": "3) Always delete backups (delete_all)",
        "enter_mods_path": "‚ùì Enter your mods folder path (or type 'help' to show common paths)",
        "path": "üìÅ Path: ",
        "common_paths": "üí° Common mods folder paths:",
        "path_invalid": "‚ùå Invalid path (not exist / not folder / no .jar found).",
        "retry": "üîÑ Retry? (Y/N, default Y): ",
        "confirm_folder": "‚úÖ Process this folder? (Y/N, default Y): ",
        "scan": "üîç Scanning mods...",
        "scan_progress": "Scan",
        "no_need": "‚ÑπÔ∏è No mods need translation.",
        "skipped": "‚è≠Ô∏è Skipped",
        "found_need": "‚úÖ Found {n} mods to translate to {lang}:",
        "confirm_translate": "‚ùì Translate all {n} mods to {lang}? (Y/N, default Y): ",
        "cancel": "‚ùå Cancelled.",
        "translate_mod": "[Translate Mod]",
        "backup_created": "üíæ Backup created:",
        "backup_exists": "‚ö†Ô∏è Backup already exists:",
        "delete_backup_ok": "‚úÖ Deleted backup:",
        "delete_backup_fail": "‚ùå Failed to delete backup:",
        "no_lang_dir": "No lang directory found",
        "summary": "üìã Summary",
        "ok": "‚úÖ Success:",
        "fail": "‚ùå Failed:",
        "folder": "üìÅ Folder:",
        "target_lang": "üåç Target language:",
        "backup_policy": "üíæ Backup policy:",
        "done": "‚úÖ Done. Thanks!",
        "press_help_tip": "Tip: On Windows, press Win+R and type %appdata%\\.minecraft\\mods",
        "throttled": "‚ö†Ô∏è Too many requests, using fallback translation:",
        "trans_err": "‚ö†Ô∏è Translate error:",
        "deleted_backups": "‚úÖ Deleted backups:"
    },

    "zh_tw": {
        "banner_title": "‚ö° Minecraft Ê®°ÁµÑË™ûË®ÄÊ™îÁøªË≠ØÂ∑•ÂÖ∑ÔºàÂè™‰øùÁïôÁøªË≠ØÂäüËÉΩÔºâ‚ö°",
        "desc": (
            "üìå Êú¨Â∑•ÂÖ∑ÊúÉÔºö\n"
            "  ‚Ä¢ ÊéÉÊèèË≥áÊñôÂ§æÂÖßÊâÄÊúâ .jar Ê®°ÁµÑ\n"
            "  ‚Ä¢ Áº∫Â∞ëÁõÆÊ®ôË™ûË®ÄÊ™îÊôÇÔºåË§áË£Ω en_us.json ‰∏¶ÁøªË≠Ø\n"
            "  ‚Ä¢ ÊØèÂÄãË¢´‰øÆÊîπÁöÑ jar ÊúÉÂª∫Á´ã .backup\n"
        ),
        "choose_ui": "üåê ÈÅ∏Êìá‰ªãÈù¢Ë™ûË®Ä",
        "choose_target": "üåç ÈÅ∏ÊìáË¶ÅÁîüÊàêÁöÑÁõÆÊ®ôË™ûË®ÄÊ™î",
        "choose_range": "‚ùì Ë´ãÈÅ∏Êìá (1-{n}ÔºåÈ†êË®≠ {d}): ",
        "choose_invalid": "‚ùå Ëº∏ÂÖ•ÁÑ°ÊïàÔºåË´ãËº∏ÂÖ•ÊúâÊïàÊï∏Â≠ó",
        "need_packages": "‚ö†Ô∏è Áº∫Â∞ë Python Â•ó‰ª∂Ôºö",
        "install_confirm": "‚úÖ Ë¶ÅËá™ÂãïÂÆâË£ùÂóéÔºü(Y/NÔºåÈ†êË®≠ Y): ",
        "install_fail": "‚ùå Â•ó‰ª∂ÂÆâË£ùÂ§±ÊïóÔºö",
        "install_hint": "üí° ÊâãÂãïÂÆâË£ù: pip install --user requests tqdm tomli",
        "backup_menu": "üíæ ÂÇô‰ªΩÈÅ∏È†Ö",
        "backup_keep": "1) ‰øùÁïôÊâÄÊúâÂÇô‰ªΩ (keep)",
        "backup_delete_success": "2) ÊàêÂäüÂæåÂà™Èô§ÂÇô‰ªΩ (delete_success)",
        "backup_delete_all": "3) ÂÆåÊàêÂæåÁ∏ΩÊòØÂà™Èô§ÂÇô‰ªΩ (delete_all)",
        "enter_mods_path": "‚ùì Ë´ãËº∏ÂÖ• mods Ë≥áÊñôÂ§æË∑ØÂæëÔºàÊàñËº∏ÂÖ• help È°ØÁ§∫Â∏∏Ë¶ãË∑ØÂæëÔºâ",
        "path": "üìÅ Ë∑ØÂæë: ",
        "common_paths": "üí° Â∏∏Ë¶ã mods Ë≥áÊñôÂ§æË∑ØÂæëÔºö",
        "path_invalid": "‚ùå Ë∑ØÂæëÁÑ°ÊïàÔºà‰∏çÂ≠òÂú®/‰∏çÊòØË≥áÊñôÂ§æ/Êâæ‰∏çÂà∞ .jarÔºâ",
        "retry": "üîÑ Ë¶ÅÈáçË©¶ÂóéÔºü(Y/NÔºåÈ†êË®≠ Y): ",
        "confirm_folder": "‚úÖ Á¢∫Ë™çËôïÁêÜË©≤Ë≥áÊñôÂ§æÔºü(Y/NÔºåÈ†êË®≠ Y): ",
        "scan": "üîç ÊéÉÊèèÊ®°ÁµÑ‰∏≠‚Ä¶",
        "scan_progress": "ÊéÉÊèèÈÄ≤Â∫¶",
        "no_need": "‚ÑπÔ∏è Ê≤íÊúâÈúÄË¶ÅÁøªË≠ØÁöÑÊ®°ÁµÑÔºÅ",
        "skipped": "‚è≠Ô∏è Ë∑≥ÈÅé",
        "found_need": "‚úÖ ÊâæÂà∞ {n} ÂÄãÈúÄË¶ÅÁøªË≠ØÊàê {lang} ÁöÑÊ®°ÁµÑÔºö",
        "confirm_translate": "‚ùì Á¢∫Ë™çÁøªË≠ØÂÖ®ÈÉ® {n} ÂÄãÊ®°ÁµÑÊàê {lang} ÂóéÔºü(Y/NÔºåÈ†êË®≠ Y): ",
        "cancel": "‚ùå Êìç‰ΩúÂ∑≤ÂèñÊ∂à",
        "translate_mod": "„ÄêÁøªË≠ØÊ®°ÁµÑ„Äë",
        "backup_created": "üíæ Âª∫Á´ãÂÇô‰ªΩÔºö",
        "backup_exists": "‚ö†Ô∏è ÂÇô‰ªΩÂ∑≤Â≠òÂú®Ôºö",
        "delete_backup_ok": "‚úÖ Â∑≤Âà™Èô§ÂÇô‰ªΩÔºö",
        "delete_backup_fail": "‚ùå Âà™Èô§ÂÇô‰ªΩÂ§±ÊïóÔºö",
        "no_lang_dir": "Êú™ÊâæÂà∞‰ªª‰Ωï lang Ë≥áÊñôÂ§æ",
        "summary": "üìã ËôïÁêÜÊëòË¶Å",
        "ok": "‚úÖ ÊàêÂäüÔºö",
        "fail": "‚ùå Â§±ÊïóÔºö",
        "folder": "üìÅ Ë≥áÊñôÂ§æÔºö",
        "target_lang": "üåç ÁõÆÊ®ôË™ûË®ÄÔºö",
        "backup_policy": "üíæ ÂÇô‰ªΩÁÆ°ÁêÜÔºö",
        "done": "‚úÖ Á®ãÂºèÂü∑Ë°åÂÆåÊàêÔºåË¨ùË¨ù‰ΩøÁî®ÔºÅ",
        "press_help_tip": "ÊèêÁ§∫ÔºöWindows ÂèØ Win+R Ëº∏ÂÖ• %appdata%\\.minecraft\\mods",
        "throttled": "‚ö†Ô∏è Ë´ãÊ±ÇÈÅéÊñºÈ†ªÁπÅÔºå‰ΩøÁî®ÂÇôÁî®ÁøªË≠ØÔºö",
        "trans_err": "‚ö†Ô∏è ÁøªË≠ØÈåØË™§Ôºö",
        "deleted_backups": "‚úÖ Â∑≤Âà™Èô§ÂÇô‰ªΩÔºö"
    },

    "zh_cn": {
        "banner_title": "‚ö° Minecraft Ê®°ÁªÑËØ≠Ë®ÄÊñá‰ª∂ÁøªËØëÂ∑•ÂÖ∑Ôºà‰ªÖÁøªËØëÂäüËÉΩÔºâ‚ö°",
        "desc": (
            "üìå Êú¨Â∑•ÂÖ∑‰ºöÔºö\n"
            "  ‚Ä¢ Êâ´ÊèèÊñá‰ª∂Â§πÂÜÖÊâÄÊúâ .jar Ê®°ÁªÑ\n"
            "  ‚Ä¢ Áº∫Â∞ëÁõÆÊ†áËØ≠Ë®ÄÊñá‰ª∂Êó∂ÔºåÂ§çÂà∂ en_us.json Âπ∂ÁøªËØë\n"
            "  ‚Ä¢ ÊØè‰∏™Ë¢´‰øÆÊîπÁöÑ jar ‰ºöÂàõÂª∫ .backup\n"
        ),
        "choose_ui": "üåê ÈÄâÊã©ÁïåÈù¢ËØ≠Ë®Ä",
        "choose_target": "üåç ÈÄâÊã©Ë¶ÅÁîüÊàêÁöÑÁõÆÊ†áËØ≠Ë®ÄÊñá‰ª∂",
        "choose_range": "‚ùì ËØ∑ÈÄâÊã© (1-{n}ÔºåÈªòËÆ§ {d}): ",
        "choose_invalid": "‚ùå ËæìÂÖ•Êó†ÊïàÔºåËØ∑ËæìÂÖ•ÊúâÊïàÊï∞Â≠ó",
        "need_packages": "‚ö†Ô∏è Áº∫Â∞ë Python Â•ó‰ª∂Ôºö",
        "install_confirm": "‚úÖ Ë¶ÅËá™Âä®ÂÆâË£ÖÂêóÔºü(Y/NÔºåÈªòËÆ§ Y): ",
        "install_fail": "‚ùå ÂÆâË£ÖÂ§±Ë¥•Ôºö",
        "install_hint": "üí° ÊâãÂä®ÂÆâË£Ö: pip install --user requests tqdm tomli",
        "backup_menu": "üíæ Â§á‰ªΩÈÄâÈ°π",
        "backup_keep": "1) ‰øùÁïôÊâÄÊúâÂ§á‰ªΩ (keep)",
        "backup_delete_success": "2) ÊàêÂäüÂêéÂà†Èô§Â§á‰ªΩ (delete_success)",
        "backup_delete_all": "3) ÂÆåÊàêÂêéÊÄªÊòØÂà†Èô§Â§á‰ªΩ (delete_all)",
        "enter_mods_path": "‚ùì ËØ∑ËæìÂÖ• mods Êñá‰ª∂Â§πË∑ØÂæÑÔºàÊàñËæìÂÖ• help ÊòæÁ§∫Â∏∏ËßÅË∑ØÂæÑÔºâ",
        "path": "üìÅ Ë∑ØÂæÑ: ",
        "common_paths": "üí° Â∏∏ËßÅ mods Êñá‰ª∂Â§πË∑ØÂæÑÔºö",
        "path_invalid": "‚ùå Ë∑ØÂæÑÊó†ÊïàÔºà‰∏çÂ≠òÂú®/‰∏çÊòØÊñá‰ª∂Â§π/Êâæ‰∏çÂà∞ .jarÔºâ",
        "retry": "üîÑ ÈáçËØïÔºü(Y/NÔºåÈªòËÆ§ Y): ",
        "confirm_folder": "‚úÖ Á°ÆËÆ§Â§ÑÁêÜËØ•Êñá‰ª∂Â§πÔºü(Y/NÔºåÈªòËÆ§ Y): ",
        "scan": "üîç Ê≠£Âú®Êâ´ÊèèÊ®°ÁªÑ‚Ä¶",
        "scan_progress": "Êâ´ÊèèËøõÂ∫¶",
        "no_need": "‚ÑπÔ∏è Ê≤°ÊúâÈúÄË¶ÅÁøªËØëÁöÑÊ®°ÁªÑÔºÅ",
        "skipped": "‚è≠Ô∏è Ë∑≥Ëøá",
        "found_need": "‚úÖ ÊâæÂà∞ {n} ‰∏™ÈúÄË¶ÅÁøªËØëÊàê {lang} ÁöÑÊ®°ÁªÑÔºö",
        "confirm_translate": "‚ùì Á°ÆËÆ§ÁøªËØëÂÖ®ÈÉ® {n} ‰∏™Ê®°ÁªÑÊàê {lang} ÂêóÔºü(Y/NÔºåÈªòËÆ§ Y): ",
        "cancel": "‚ùå Â∑≤ÂèñÊ∂à",
        "translate_mod": "„ÄêÁøªËØëÊ®°ÁªÑ„Äë",
        "backup_created": "üíæ Â∑≤ÂàõÂª∫Â§á‰ªΩÔºö",
        "backup_exists": "‚ö†Ô∏è Â§á‰ªΩÂ∑≤Â≠òÂú®Ôºö",
        "delete_backup_ok": "‚úÖ Â∑≤Âà†Èô§Â§á‰ªΩÔºö",
        "delete_backup_fail": "‚ùå Âà†Èô§Â§á‰ªΩÂ§±Ë¥•Ôºö",
        "no_lang_dir": "Êú™ÊâæÂà∞‰ªª‰Ωï lang Êñá‰ª∂Â§π",
        "summary": "üìã ÊëòË¶Å",
        "ok": "‚úÖ ÊàêÂäüÔºö",
        "fail": "‚ùå Â§±Ë¥•Ôºö",
        "folder": "üìÅ Êñá‰ª∂Â§πÔºö",
        "target_lang": "üåç ÁõÆÊ†áËØ≠Ë®ÄÔºö",
        "backup_policy": "üíæ Â§á‰ªΩÁ≠ñÁï•Ôºö",
        "done": "‚úÖ Á®ãÂ∫èÂÆåÊàêÔºåÊÑüË∞¢‰ΩøÁî®ÔºÅ",
        "press_help_tip": "ÊèêÁ§∫ÔºöWindows ÂèØ Win+R ËæìÂÖ• %appdata%\\.minecraft\\mods",
        "throttled": "‚ö†Ô∏è ËØ∑Ê±ÇËøá‰∫éÈ¢ëÁπÅÔºå‰ΩøÁî®Â§áÁî®ÁøªËØëÔºö",
        "trans_err": "‚ö†Ô∏è ÁøªËØëÈîôËØØÔºö",
        "deleted_backups": "‚úÖ Â∑≤Âà†Èô§Â§á‰ªΩÔºö"
    },

    "ja_jp": {
        "banner_title": "‚ö° Minecraft MOD Ë®ÄË™û„Éï„Ç°„Ç§„É´ÁøªË®≥„ÉÑ„Éº„É´ÔºàÁøªË®≥„ÅÆ„ÅøÔºâ‚ö°",
        "desc": (
            "„Åì„ÅÆ„ÉÑ„Éº„É´„ÅØÔºö\n"
            "  ‚Ä¢ „Éï„Ç©„É´„ÉÄ„ÉºÂÜÖ„ÅÆ .jar MOD „Çí„Çπ„Ç≠„É£„É≥\n"
            "  ‚Ä¢ ÁõÆÁöÑ„ÅÆË®ÄË™û„Éï„Ç°„Ç§„É´„ÅåÁÑ°„Åë„Çå„Å∞„ÄÅen_us.json „Çí„Ç≥„Éî„Éº„Åó„Å¶ÁøªË®≥\n"
            "  ‚Ä¢ Â§âÊõ¥„Åó„Åü jar „Åî„Å®„Å´ .backup „Çí‰ΩúÊàê\n"
        ),
        "choose_ui": "üåê UI Ë®ÄË™û„ÇíÈÅ∏Êäû",
        "choose_target": "üåç ÁîüÊàê„Åô„ÇãÁõÆÊ®ôË®ÄË™û„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû",
        "choose_range": "‚ùì ÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ (1-{n}„ÄÅ„Éá„Éï„Ç©„É´„Éà {d}): ",
        "choose_invalid": "‚ùå ÁÑ°Âäπ„Å™ÂÖ•Âäõ„Åß„Åô„ÄÇÊï∞Â≠ó„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
        "need_packages": "‚ö†Ô∏è ÂøÖË¶Å„Å™ Python „Éë„ÉÉ„Ç±„Éº„Ç∏„Åå‰∏çË∂≥„Åó„Å¶„ÅÑ„Åæ„ÅôÔºö",
        "install_confirm": "‚úÖ Ëá™Âãï„Åß„Ç§„É≥„Çπ„Éà„Éº„É´„Åó„Åæ„Åô„ÅãÔºü(Y/N„ÄÅ„Éá„Éï„Ç©„É´„Éà Y): ",
        "install_fail": "‚ùå „Ç§„É≥„Çπ„Éà„Éº„É´„Å´Â§±Êïó„Åó„Åæ„Åó„ÅüÔºö",
        "install_hint": "üí° ÊâãÂãï: pip install --user requests tqdm tomli",
        "backup_menu": "üíæ „Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóË®≠ÂÆö",
        "backup_keep": "1) „Åô„Åπ„Å¶‰øùÊåÅ (keep)",
        "backup_delete_success": "2) ÊàêÂäüÊôÇ„ÅÆ„ÅøÂâäÈô§ (delete_success)",
        "backup_delete_all": "3) Â∏∏„Å´ÂâäÈô§ (delete_all)",
        "enter_mods_path": "‚ùì mods „Éï„Ç©„É´„ÉÄ„Éº„ÅÆ„Éë„Çπ„ÇíÂÖ•ÂäõÔºà„Åæ„Åü„ÅØ help „ÅßÂÄôË£úË°®Á§∫Ôºâ",
        "path": "üìÅ „Éë„Çπ: ",
        "common_paths": "üí° „Çà„Åè„ÅÇ„Çã mods „Éï„Ç©„É´„ÉÄ„ÉºÔºö",
        "path_invalid": "‚ùå ÁÑ°Âäπ„Å™„Éë„ÇπÔºàÂ≠òÂú®„Åó„Å™„ÅÑ/„Éï„Ç©„É´„ÉÄ„Éº„Åß„ÅØ„Å™„ÅÑ/.jar „Åå„Å™„ÅÑÔºâ",
        "retry": "üîÑ ÂÜçÂÖ•Âäõ„Åó„Åæ„Åô„ÅãÔºü(Y/N„ÄÅ„Éá„Éï„Ç©„É´„Éà Y): ",
        "confirm_folder": "‚úÖ „Åì„ÅÆ„Éï„Ç©„É´„ÉÄ„Éº„ÇíÂá¶ÁêÜ„Åó„Åæ„Åô„ÅãÔºü(Y/N„ÄÅ„Éá„Éï„Ç©„É´„Éà Y): ",
        "scan": "üîç MOD „Çí„Çπ„Ç≠„É£„É≥‰∏≠‚Ä¶",
        "scan_progress": "„Çπ„Ç≠„É£„É≥",
        "no_need": "‚ÑπÔ∏è ÁøªË®≥„ÅåÂøÖË¶Å„Å™ MOD „ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ",
        "skipped": "‚è≠Ô∏è „Çπ„Ç≠„ÉÉ„Éó",
        "found_need": "‚úÖ {lang} „Å´ÁøªË®≥„ÅåÂøÖË¶Å„Å™ MOD „Åå {n} ÂÄãË¶ã„Å§„Åã„Çä„Åæ„Åó„ÅüÔºö",
        "confirm_translate": "‚ùì {n} ÂÄã„Åô„Åπ„Å¶„Çí {lang} „Å´ÁøªË®≥„Åó„Åæ„Åô„ÅãÔºü(Y/N„ÄÅ„Éá„Éï„Ç©„É´„Éà Y): ",
        "cancel": "‚ùå „Ç≠„É£„É≥„Çª„É´„Åó„Åæ„Åó„Åü„ÄÇ",
        "translate_mod": "„ÄêÁøªË®≥ MOD„Äë",
        "backup_created": "üíæ „Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„Éó‰ΩúÊàêÔºö",
        "backup_exists": "‚ö†Ô∏è „Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÊó¢Â≠òÔºö",
        "delete_backup_ok": "‚úÖ „Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÂâäÈô§Ôºö",
        "delete_backup_fail": "‚ùå „Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÂâäÈô§Â§±ÊïóÔºö",
        "no_lang_dir": "lang „Éï„Ç©„É´„ÉÄ„Éº„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì",
        "summary": "üìã ÁµêÊûú",
        "ok": "‚úÖ ÊàêÂäüÔºö",
        "fail": "‚ùå Â§±ÊïóÔºö",
        "folder": "üìÅ „Éï„Ç©„É´„ÉÄ„ÉºÔºö",
        "target_lang": "üåç ÁõÆÊ®ôË®ÄË™ûÔºö",
        "backup_policy": "üíæ „Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÔºö",
        "done": "‚úÖ ÂÆå‰∫Ü„Åó„Åæ„Åó„Åü„ÄÇ„ÅÇ„Çä„Åå„Å®„ÅÜÔºÅ",
        "press_help_tip": "„Éí„É≥„ÉàÔºöWindows „ÅØ Win+R ‚Üí %appdata%\\.minecraft\\mods",
        "throttled": "‚ö†Ô∏è „É™„ÇØ„Ç®„Çπ„ÉàÈÅéÂ§ö„ÄÇ‰ª£ÊõøÁøªË®≥„Çí‰ΩøÁî®Ôºö",
        "trans_err": "‚ö†Ô∏è ÁøªË®≥„Ç®„É©„ÉºÔºö",
        "deleted_backups": "‚úÖ ÂâäÈô§„Åó„Åü„Éê„ÉÉ„ÇØ„Ç¢„ÉÉ„ÉóÔºö"
    },

    "ko_kr": {
        "banner_title": "‚ö° Minecraft Î™®Îìú Ïñ∏Ïñ¥ ÌååÏùº Î≤àÏó≠Í∏∞(Î≤àÏó≠ Í∏∞Îä•Îßå) ‚ö°",
        "desc": (
            "Ïù¥ ÎèÑÍµ¨Îäî:\n"
            "  ‚Ä¢ Ìè¥ÎçîÏùò Î™®Îì† .jar Î™®ÎìúÎ•º Ïä§Ï∫î\n"
            "  ‚Ä¢ ÎåÄÏÉÅ Ïñ∏Ïñ¥ ÌååÏùºÏù¥ ÏóÜÏúºÎ©¥ en_us.jsonÏùÑ Î≥µÏÇ¨ ÌõÑ Î≤àÏó≠\n"
            "  ‚Ä¢ ÏàòÏ†ïÎêú jarÎßàÎã§ .backup ÏÉùÏÑ±\n"
        ),
        "choose_ui": "üåê UI Ïñ∏Ïñ¥ ÏÑ†ÌÉù",
        "choose_target": "üåç ÏÉùÏÑ±Ìï† ÎåÄÏÉÅ Ïñ∏Ïñ¥ ÌååÏùº ÏÑ†ÌÉù",
        "choose_range": "‚ùì ÏÑ†ÌÉù (1-{n}, Í∏∞Î≥∏ {d}): ",
        "choose_invalid": "‚ùå ÏûòÎ™ªÎêú ÏûÖÎ†•ÏûÖÎãàÎã§. Ïà´ÏûêÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.",
        "need_packages": "‚ö†Ô∏è ÌïÑÏöîÌïú Python Ìå®ÌÇ§ÏßÄÍ∞Ä ÏóÜÏäµÎãàÎã§:",
        "install_confirm": "‚úÖ ÏûêÎèô ÏÑ§ÏπòÌï†ÍπåÏöî? (Y/N, Í∏∞Î≥∏ Y): ",
        "install_fail": "‚ùå ÏÑ§Ïπò Ïã§Ìå®:",
        "install_hint": "üí° ÏàòÎèô: pip install --user requests tqdm tomli",
        "backup_menu": "üíæ Î∞±ÏóÖ ÏòµÏÖò",
        "backup_keep": "1) Î∞±ÏóÖ Î™®Îëê Ïú†ÏßÄ (keep)",
        "backup_delete_success": "2) ÏÑ±Í≥µ ÏãúÏóêÎßå ÏÇ≠Ï†ú (delete_success)",
        "backup_delete_all": "3) Ìï≠ÏÉÅ ÏÇ≠Ï†ú (delete_all)",
        "enter_mods_path": "‚ùì mods Ìè¥Îçî Í≤ΩÎ°ú ÏûÖÎ†•(ÎòêÎäî helpÎ°ú ÏùºÎ∞ò Í≤ΩÎ°ú ÌëúÏãú)",
        "path": "üìÅ Í≤ΩÎ°ú: ",
        "common_paths": "üí° ÏùºÎ∞òÏ†ÅÏù∏ mods Ìè¥Îçî Í≤ΩÎ°ú:",
        "path_invalid": "‚ùå ÏûòÎ™ªÎêú Í≤ΩÎ°ú(ÏóÜÏùå/Ìè¥Îçî ÏïÑÎãò/.jar ÏóÜÏùå)",
        "retry": "üîÑ Îã§Ïãú ÏãúÎèÑÌï†ÍπåÏöî? (Y/N, Í∏∞Î≥∏ Y): ",
        "confirm_folder": "‚úÖ Ïù¥ Ìè¥ÎçîÎ•º Ï≤òÎ¶¨Ìï†ÍπåÏöî? (Y/N, Í∏∞Î≥∏ Y): ",
        "scan": "üîç Î™®Îìú Ïä§Ï∫î Ï§ë‚Ä¶",
        "scan_progress": "Ïä§Ï∫î",
        "no_need": "‚ÑπÔ∏è Î≤àÏó≠Ïù¥ ÌïÑÏöîÌïú Î™®ÎìúÍ∞Ä ÏóÜÏäµÎãàÎã§.",
        "skipped": "‚è≠Ô∏è Í±¥ÎÑàÎúÄ",
        "found_need": "‚úÖ {lang}Î°ú Î≤àÏó≠Ìï† Î™®Îìú {n}Í∞ú Î∞úÍ≤¨:",
        "confirm_translate": "‚ùì {n}Í∞ú Î™®Îëê {lang}Î°ú Î≤àÏó≠Ìï†ÍπåÏöî? (Y/N, Í∏∞Î≥∏ Y): ",
        "cancel": "‚ùå Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.",
        "translate_mod": "„ÄêÎ™®Îìú Î≤àÏó≠„Äë",
        "backup_created": "üíæ Î∞±ÏóÖ ÏÉùÏÑ±:",
        "backup_exists": "‚ö†Ô∏è Î∞±ÏóÖÏù¥ Ïù¥ÎØ∏ Ï°¥Ïû¨:",
        "delete_backup_ok": "‚úÖ Î∞±ÏóÖ ÏÇ≠Ï†ú:",
        "delete_backup_fail": "‚ùå Î∞±ÏóÖ ÏÇ≠Ï†ú Ïã§Ìå®:",
        "no_lang_dir": "lang Ìè¥ÎçîÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§",
        "summary": "üìã ÏöîÏïΩ",
        "ok": "‚úÖ ÏÑ±Í≥µ:",
        "fail": "‚ùå Ïã§Ìå®:",
        "folder": "üìÅ Ìè¥Îçî:",
        "target_lang": "üåç ÎåÄÏÉÅ Ïñ∏Ïñ¥:",
        "backup_policy": "üíæ Î∞±ÏóÖ Ï†ïÏ±Ö:",
        "done": "‚úÖ ÏôÑÎ£å. Í∞êÏÇ¨Ìï©ÎãàÎã§!",
        "press_help_tip": "ÌåÅ: WindowsÎäî Win+R ‚Üí %appdata%\\.minecraft\\mods",
        "throttled": "‚ö†Ô∏è ÏöîÏ≤≠Ïù¥ ÎÑàÎ¨¥ ÎßéÏïÑ ÎåÄÏ≤¥ Î≤àÏó≠ ÏÇ¨Ïö©:",
        "trans_err": "‚ö†Ô∏è Î≤àÏó≠ Ïò§Î•ò:",
        "deleted_backups": "‚úÖ ÏÇ≠Ï†úÌïú Î∞±ÏóÖ:"
    },

    "es_es": {
        "banner_title": "‚ö° Traductor de archivos de idioma para Mods de Minecraft (solo traducci√≥n) ‚ö°",
        "desc": (
            "Esta herramienta:\n"
            "  ‚Ä¢ Escanea todos los mods .jar de una carpeta\n"
            "  ‚Ä¢ Si falta el idioma objetivo, copia en_us.json y traduce\n"
            "  ‚Ä¢ Crea .backup por cada jar modificado\n"
        ),
        "choose_ui": "üåê Elegir idioma de la interfaz",
        "choose_target": "üåç Elegir idioma objetivo a generar",
        "choose_range": "‚ùì Elige (1-{n}, por defecto {d}): ",
        "choose_invalid": "‚ùå Entrada inv√°lida. Introduce un n√∫mero.",
        "need_packages": "‚ö†Ô∏è Faltan paquetes de Python:",
        "install_confirm": "‚úÖ ¬øInstalarlos autom√°ticamente? (Y/N, por defecto Y): ",
        "install_fail": "‚ùå Error al instalar:",
        "install_hint": "üí° Manual: pip install --user requests tqdm tomli",
        "backup_menu": "üíæ Opci√≥n de copia de seguridad",
        "backup_keep": "1) Conservar todas las copias (keep)",
        "backup_delete_success": "2) Borrar solo si tuvo √©xito (delete_success)",
        "backup_delete_all": "3) Borrar siempre (delete_all)",
        "enter_mods_path": "‚ùì Introduce la ruta de la carpeta mods (o escribe help para ver rutas comunes)",
        "path": "üìÅ Ruta: ",
        "common_paths": "üí° Rutas comunes de mods:",
        "path_invalid": "‚ùå Ruta inv√°lida (no existe/no es carpeta/no hay .jar)",
        "retry": "üîÑ ¬øReintentar? (Y/N, por defecto Y): ",
        "confirm_folder": "‚úÖ ¬øProcesar esta carpeta? (Y/N, por defecto Y): ",
        "scan": "üîç Escaneando mods‚Ä¶",
        "scan_progress": "Escaneo",
        "no_need": "‚ÑπÔ∏è No hay mods que necesiten traducci√≥n.",
        "skipped": "‚è≠Ô∏è Omitidos",
        "found_need": "‚úÖ Encontrados {n} mods para traducir a {lang}:",
        "confirm_translate": "‚ùì ¬øTraducir los {n} mods a {lang}? (Y/N, por defecto Y): ",
        "cancel": "‚ùå Cancelado.",
        "translate_mod": "[Traducir Mod]",
        "backup_created": "üíæ Copia creada:",
        "backup_exists": "‚ö†Ô∏è Copia ya existe:",
        "delete_backup_ok": "‚úÖ Copia borrada:",
        "delete_backup_fail": "‚ùå No se pudo borrar la copia:",
        "no_lang_dir": "No se encontr√≥ la carpeta lang",
        "summary": "üìã Resumen",
        "ok": "‚úÖ √âxito:",
        "fail": "‚ùå Fallo:",
        "folder": "üìÅ Carpeta:",
        "target_lang": "üåç Idioma objetivo:",
        "backup_policy": "üíæ Pol√≠tica de copias:",
        "done": "‚úÖ Listo. ¬°Gracias!",
        "press_help_tip": "Consejo: En Windows Win+R ‚Üí %appdata%\\.minecraft\\mods",
        "throttled": "‚ö†Ô∏è Demasiadas solicitudes, usando traducci√≥n alternativa:",
        "trans_err": "‚ö†Ô∏è Error de traducci√≥n:",
        "deleted_backups": "‚úÖ Copias borradas:"
    },

    "ru_ru": {
        "banner_title": "‚ö° –ü–µ—Ä–µ–≤–æ–¥—á–∏–∫ —è–∑—ã–∫–æ–≤—ã—Ö —Ñ–∞–π–ª–æ–≤ –º–æ–¥–æ–≤ Minecraft (—Ç–æ–ª—å–∫–æ –ø–µ—Ä–µ–≤–æ–¥) ‚ö°",
        "desc": (
            "–≠—Ç–æ—Ç –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç:\n"
            "  ‚Ä¢ –°–∫–∞–Ω–∏—Ä—É–µ—Ç –≤—Å–µ .jar –º–æ–¥—ã –≤ –ø–∞–ø–∫–µ\n"
            "  ‚Ä¢ –ï—Å–ª–∏ –Ω–µ—Ç —Ü–µ–ª–µ–≤–æ–≥–æ —è–∑—ã–∫–∞ ‚Äî –∫–æ–ø–∏—Ä—É–µ—Ç en_us.json –∏ –ø–µ—Ä–µ–≤–æ–¥–∏—Ç\n"
            "  ‚Ä¢ –°–æ–∑–¥–∞—ë—Ç .backup –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∏–∑–º–µ–Ω—ë–Ω–Ω–æ–≥–æ jar\n"
        ),
        "choose_ui": "üåê –í—ã–±–µ—Ä–∏—Ç–µ —è–∑—ã–∫ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞",
        "choose_target": "üåç –í—ã–±–µ—Ä–∏—Ç–µ —Ü–µ–ª–µ–≤–æ–π —è–∑—ã–∫ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏",
        "choose_range": "‚ùì –í—ã–±–µ—Ä–∏—Ç–µ (1-{n}, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é {d}): ",
        "choose_invalid": "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –≤–≤–æ–¥. –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ.",
        "need_packages": "‚ö†Ô∏è –ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –ø–∞–∫–µ—Ç–æ–≤ Python:",
        "install_confirm": "‚úÖ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏? (Y/N, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é Y): ",
        "install_fail": "‚ùå –û—à–∏–±–∫–∞ —É—Å—Ç–∞–Ω–æ–≤–∫–∏:",
        "install_hint": "üí° –í—Ä—É—á–Ω—É—é: pip install --user requests tqdm tomli",
        "backup_menu": "üíæ –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ä–µ–∑–µ—Ä–≤–Ω—ã—Ö –∫–æ–ø–∏–π",
        "backup_keep": "1) –°–æ—Ö—Ä–∞–Ω—è—Ç—å –≤—Å–µ (keep)",
        "backup_delete_success": "2) –£–¥–∞–ª—è—Ç—å —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —É—Å–ø–µ—Ö–µ (delete_success)",
        "backup_delete_all": "3) –í—Å–µ–≥–¥–∞ —É–¥–∞–ª—è—Ç—å (delete_all)",
        "enter_mods_path": "‚ùì –í–≤–µ–¥–∏—Ç–µ –ø—É—Ç—å –∫ –ø–∞–ø–∫–µ mods (–∏–ª–∏ help –¥–ª—è –ø–æ–¥—Å–∫–∞–∑–∫–∏)",
        "path": "üìÅ –ü—É—Ç—å: ",
        "common_paths": "üí° –ß–∞—Å—Ç—ã–µ –ø—É—Ç–∏ mods:",
        "path_invalid": "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –ø—É—Ç—å (–Ω–µ—Ç/–Ω–µ –ø–∞–ø–∫–∞/–Ω–µ—Ç .jar)",
        "retry": "üîÑ –ü–æ–≤—Ç–æ—Ä–∏—Ç—å? (Y/N, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é Y): ",
        "confirm_folder": "‚úÖ –û–±—Ä–∞–±–æ—Ç–∞—Ç—å —ç—Ç—É –ø–∞–ø–∫—É? (Y/N, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é Y): ",
        "scan": "üîç –°–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –º–æ–¥–æ–≤‚Ä¶",
        "scan_progress": "–°–∫–∞–Ω",
        "no_need": "‚ÑπÔ∏è –ú–æ–¥–æ–≤ –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ –Ω–µ—Ç.",
        "skipped": "‚è≠Ô∏è –ü—Ä–æ–ø—É—â–µ–Ω–æ",
        "found_need": "‚úÖ –ù–∞–π–¥–µ–Ω–æ {n} –º–æ–¥–æ–≤ –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ –Ω–∞ {lang}:",
        "confirm_translate": "‚ùì –ü–µ—Ä–µ–≤–µ—Å—Ç–∏ –≤—Å–µ {n} –º–æ–¥–æ–≤ –Ω–∞ {lang}? (Y/N, –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é Y): ",
        "cancel": "‚ùå –û—Ç–º–µ–Ω–µ–Ω–æ.",
        "translate_mod": "[–ü–µ—Ä–µ–≤–æ–¥ –º–æ–¥–∞]",
        "backup_created": "üíæ –ë—ç–∫–∞–ø —Å–æ–∑–¥–∞–Ω:",
        "backup_exists": "‚ö†Ô∏è –ë—ç–∫–∞–ø —É–∂–µ –µ—Å—Ç—å:",
        "delete_backup_ok": "‚úÖ –ë—ç–∫–∞–ø —É–¥–∞–ª—ë–Ω:",
        "delete_backup_fail": "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å –±—ç–∫–∞–ø:",
        "no_lang_dir": "–ü–∞–ø–∫–∞ lang –Ω–µ –Ω–∞–π–¥–µ–Ω–∞",
        "summary": "üìã –ò—Ç–æ–≥–∏",
        "ok": "‚úÖ –£—Å–ø–µ—à–Ω–æ:",
        "fail": "‚ùå –û—à–∏–±–∫–∞:",
        "folder": "üìÅ –ü–∞–ø–∫–∞:",
        "target_lang": "üåç –¶–µ–ª–µ–≤–æ–π —è–∑—ã–∫:",
        "backup_policy": "üíæ –ë—ç–∫–∞–ø—ã:",
        "done": "‚úÖ –ì–æ—Ç–æ–≤–æ. –°–ø–∞—Å–∏–±–æ!",
        "press_help_tip": "–ü–æ–¥—Å–∫–∞–∑–∫–∞: Windows Win+R ‚Üí %appdata%\\.minecraft\\mods",
        "throttled": "‚ö†Ô∏è –°–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∑–∞–ø—Ä–æ—Å–æ–≤, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∑–∞–ø–∞—Å–Ω–æ–π –ø–µ—Ä–µ–≤–æ–¥:",
        "trans_err": "‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–≤–æ–¥–∞:",
        "deleted_backups": "‚úÖ –£–¥–∞–ª–µ–Ω–æ –±—ç–∫–∞–ø–æ–≤:"
    },

    "de_de": {
        "banner_title": "‚ö° Minecraft Mod Sprachdatei-√úbersetzer (nur √úbersetzung) ‚ö°",
        "desc": (
            "Dieses Tool:\n"
            "  ‚Ä¢ Scannt alle .jar Mods in einem Ordner\n"
            "  ‚Ä¢ Fehlt die Zielsprache, wird en_us.json kopiert und √ºbersetzt\n"
            "  ‚Ä¢ Erstellt f√ºr jedes ge√§nderte jar ein .backup\n"
        ),
        "choose_ui": "üåê UI-Sprache w√§hlen",
        "choose_target": "üåç Zielsprache (Datei) w√§hlen",
        "choose_range": "‚ùì W√§hle (1-{n}, Standard {d}): ",
        "choose_invalid": "‚ùå Ung√ºltige Eingabe. Bitte Zahl eingeben.",
        "need_packages": "‚ö†Ô∏è Fehlende Python-Pakete:",
        "install_confirm": "‚úÖ Automatisch installieren? (Y/N, Standard Y): ",
        "install_fail": "‚ùå Installation fehlgeschlagen:",
        "install_hint": "üí° Manuell: pip install --user requests tqdm tomli",
        "backup_menu": "üíæ Backup-Option",
        "backup_keep": "1) Alle Backups behalten (keep)",
        "backup_delete_success": "2) Nur bei Erfolg l√∂schen (delete_success)",
        "backup_delete_all": "3) Immer l√∂schen (delete_all)",
        "enter_mods_path": "‚ùì Pfad zum mods-Ordner eingeben (oder help f√ºr typische Pfade)",
        "path": "üìÅ Pfad: ",
        "common_paths": "üí° Typische mods-Pfade:",
        "path_invalid": "‚ùå Ung√ºltiger Pfad (nicht vorhanden/kein Ordner/keine .jar)",
        "retry": "üîÑ Erneut versuchen? (Y/N, Standard Y): ",
        "confirm_folder": "‚úÖ Diesen Ordner verarbeiten? (Y/N, Standard Y): ",
        "scan": "üîç Scanne Mods‚Ä¶",
        "scan_progress": "Scan",
        "no_need": "‚ÑπÔ∏è Keine Mods ben√∂tigen eine √úbersetzung.",
        "skipped": "‚è≠Ô∏è √úbersprungen",
        "found_need": "‚úÖ {n} Mods zum √úbersetzen nach {lang} gefunden:",
        "confirm_translate": "‚ùì Alle {n} Mods nach {lang} √ºbersetzen? (Y/N, Standard Y): ",
        "cancel": "‚ùå Abgebrochen.",
        "translate_mod": "[Mod √ºbersetzen]",
        "backup_created": "üíæ Backup erstellt:",
        "backup_exists": "‚ö†Ô∏è Backup existiert bereits:",
        "delete_backup_ok": "‚úÖ Backup gel√∂scht:",
        "delete_backup_fail": "‚ùå Backup konnte nicht gel√∂scht werden:",
        "no_lang_dir": "Kein lang-Ordner gefunden",
        "summary": "üìã Zusammenfassung",
        "ok": "‚úÖ Erfolgreich:",
        "fail": "‚ùå Fehlgeschlagen:",
        "folder": "üìÅ Ordner:",
        "target_lang": "üåç Zielsprache:",
        "backup_policy": "üíæ Backup-Regel:",
        "done": "‚úÖ Fertig. Danke!",
        "press_help_tip": "Tipp: Windows Win+R ‚Üí %appdata%\\.minecraft\\mods",
        "throttled": "‚ö†Ô∏è Zu viele Anfragen, Fallback-√úbersetzung wird genutzt:",
        "trans_err": "‚ö†Ô∏è √úbersetzungsfehler:",
        "deleted_backups": "‚úÖ Gel√∂schte Backups:"
    },

    "fr_fr": {
        "banner_title": "‚ö° Traducteur de fichiers de langue des mods Minecraft (traduction uniquement) ‚ö°",
        "desc": (
            "Cet outil :\n"
            "  ‚Ä¢ Analyse tous les mods .jar d‚Äôun dossier\n"
            "  ‚Ä¢ Si la langue cible manque, copie en_us.json puis traduit\n"
            "  ‚Ä¢ Cr√©e un .backup pour chaque jar modifi√©\n"
        ),
        "choose_ui": "üåê Choisir la langue de l‚Äôinterface",
        "choose_target": "üåç Choisir la langue cible √† g√©n√©rer",
        "choose_range": "‚ùì Choisir (1-{n}, par d√©faut {d}) : ",
        "choose_invalid": "‚ùå Entr√©e invalide. Entrez un nombre.",
        "need_packages": "‚ö†Ô∏è Paquets Python manquants :",
        "install_confirm": "‚úÖ Installer automatiquement ? (Y/N, par d√©faut Y) : ",
        "install_fail": "‚ùå √âchec de l‚Äôinstallation :",
        "install_hint": "üí° Manuel : pip install --user requests tqdm tomli",
        "backup_menu": "üíæ Option de sauvegarde",
        "backup_keep": "1) Conserver toutes les sauvegardes (keep)",
        "backup_delete_success": "2) Supprimer seulement si succ√®s (delete_success)",
        "backup_delete_all": "3) Toujours supprimer (delete_all)",
        "enter_mods_path": "‚ùì Entrez le chemin du dossier mods (ou help pour afficher des chemins courants)",
        "path": "üìÅ Chemin : ",
        "common_paths": "üí° Chemins mods courants :",
        "path_invalid": "‚ùå Chemin invalide (inexistant/pas un dossier/pas de .jar)",
        "retry": "üîÑ R√©essayer ? (Y/N, par d√©faut Y) : ",
        "confirm_folder": "‚úÖ Traiter ce dossier ? (Y/N, par d√©faut Y) : ",
        "scan": "üîç Analyse des mods‚Ä¶",
        "scan_progress": "Analyse",
        "no_need": "‚ÑπÔ∏è Aucun mod n‚Äôa besoin de traduction.",
        "skipped": "‚è≠Ô∏è Ignor√©s",
        "found_need": "‚úÖ {n} mods √† traduire en {lang} :",
        "confirm_translate": "‚ùì Traduire les {n} mods en {lang} ? (Y/N, par d√©faut Y) : ",
        "cancel": "‚ùå Annul√©.",
        "translate_mod": "[Traduire le mod]",
        "backup_created": "üíæ Sauvegarde cr√©√©e :",
        "backup_exists": "‚ö†Ô∏è Sauvegarde d√©j√† existante :",
        "delete_backup_ok": "‚úÖ Sauvegarde supprim√©e :",
        "delete_backup_fail": "‚ùå Impossible de supprimer la sauvegarde :",
        "no_lang_dir": "Dossier lang introuvable",
        "summary": "üìã R√©sum√©",
        "ok": "‚úÖ R√©ussi :",
        "fail": "‚ùå √âchec :",
        "folder": "üìÅ Dossier :",
        "target_lang": "üåç Langue cible :",
        "backup_policy": "üíæ Politique de sauvegarde :",
        "done": "‚úÖ Termin√©. Merci !",
        "press_help_tip": "Astuce : Windows Win+R ‚Üí %appdata%\\.minecraft\\mods",
        "throttled": "‚ö†Ô∏è Trop de requ√™tes, traduction de secours utilis√©e :",
        "trans_err": "‚ö†Ô∏è Erreur de traduction :",
        "deleted_backups": "‚úÖ Sauvegardes supprim√©es :"
    },

    "it_it": {
        "banner_title": "‚ö° Traduttore file lingua per mod di Minecraft (solo traduzione) ‚ö°",
        "desc": (
            "Questo strumento:\n"
            "  ‚Ä¢ Scansiona tutti i mod .jar in una cartella\n"
            "  ‚Ä¢ Se manca la lingua target, copia en_us.json e traduce\n"
            "  ‚Ä¢ Crea un .backup per ogni jar modificato\n"
        ),
        "choose_ui": "üåê Scegli la lingua dell'interfaccia",
        "choose_target": "üåç Scegli la lingua target da generare",
        "choose_range": "‚ùì Scegli (1-{n}, predefinito {d}): ",
        "choose_invalid": "‚ùå Input non valido. Inserisci un numero.",
        "need_packages": "‚ö†Ô∏è Mancano pacchetti Python:",
        "install_confirm": "‚úÖ Installarli automaticamente? (Y/N, predefinito Y): ",
        "install_fail": "‚ùå Installazione fallita:",
        "install_hint": "üí° Manuale: pip install --user requests tqdm tomli",
        "backup_menu": "üíæ Opzione backup",
        "backup_keep": "1) Mantieni tutti i backup (keep)",
        "backup_delete_success": "2) Elimina solo se successo (delete_success)",
        "backup_delete_all": "3) Elimina sempre (delete_all)",
        "enter_mods_path": "‚ùì Inserisci il percorso della cartella mods (o help per percorsi comuni)",
        "path": "üìÅ Percorso: ",
        "common_paths": "üí° Percorsi mods comuni:",
        "path_invalid": "‚ùå Percorso non valido (inesistente/non cartella/nessun .jar)",
        "retry": "üîÑ Riprovare? (Y/N, predefinito Y): ",
        "confirm_folder": "‚úÖ Elaborare questa cartella? (Y/N, predefinito Y): ",
        "scan": "üîç Scansione mod‚Ä¶",
        "scan_progress": "Scansione",
        "no_need": "‚ÑπÔ∏è Nessun mod richiede traduzione.",
        "skipped": "‚è≠Ô∏è Saltati",
        "found_need": "‚úÖ Trovati {n} mod da tradurre in {lang}:",
        "confirm_translate": "‚ùì Tradurre tutti i {n} mod in {lang}? (Y/N, predefinito Y): ",
        "cancel": "‚ùå Annullato.",
        "translate_mod": "[Traduci mod]",
        "backup_created": "üíæ Backup creato:",
        "backup_exists": "‚ö†Ô∏è Backup gi√† esistente:",
        "delete_backup_ok": "‚úÖ Backup eliminato:",
        "delete_backup_fail": "‚ùå Impossibile eliminare il backup:",
        "no_lang_dir": "Cartella lang non trovata",
        "summary": "üìã Riepilogo",
        "ok": "‚úÖ Successo:",
        "fail": "‚ùå Fallito:",
        "folder": "üìÅ Cartella:",
        "target_lang": "üåç Lingua target:",
        "backup_policy": "üíæ Politica backup:",
        "done": "‚úÖ Fatto. Grazie!",
        "press_help_tip": "Suggerimento: Windows Win+R ‚Üí %appdata%\\.minecraft\\mods",
        "throttled": "‚ö†Ô∏è Troppe richieste, uso traduzione di fallback:",
        "trans_err": "‚ö†Ô∏è Errore traduzione:",
        "deleted_backups": "‚úÖ Backup eliminati:"
    }
}

# =========================
# UI helper
# =========================
def ui_get(ui_lang: str, key: str) -> str:
    return UI_STRINGS.get(ui_lang, UI_STRINGS["en_us"]).get(key, UI_STRINGS["en_us"].get(key, key))

def hr():
    print("‚îÄ" * 93)

# =========================
# Packages
# =========================
def install_required_packages(ui_lang: str) -> bool:
    required_packages = ['requests', 'tqdm']
    
    # Check if we need tomli (only for Python < 3.11)
    if sys.version_info < (3, 11):
        required_packages.append('tomli')

    installed_packages = []

    try:
        import importlib
        for package in required_packages:
            try:
                importlib.import_module(package)
                installed_packages.append(package)
            except ImportError:
                pass

        missing_packages = [p for p in required_packages if p not in installed_packages]
        if missing_packages:
            print(ui_get(ui_lang, "need_packages"))
            for package in missing_packages:
                print(f"   ‚Ä¢ {package}")

            confirm = input(ui_get(ui_lang, "install_confirm")).strip().lower()
            if not confirm or confirm in ['y', 'yes']:
                try:
                    subprocess.check_call([sys.executable, '-m', 'pip', 'install', '--user'] + missing_packages)
                    # Re-import tomli if it was just installed
                    if 'tomli' in missing_packages:
                        global toml
                        import tomli as toml
                    return True
                except Exception as e:
                    print(ui_get(ui_lang, "install_fail"), str(e))
                    print(ui_get(ui_lang, "install_hint"))
                    return False
            return False

        return True

    except Exception as e:
        print(ui_get(ui_lang, "install_fail"), str(e))
        return False

# =========================
# Paths
# =========================
def get_common_minecraft_paths():
    system = platform.system().lower()
    home_dir = os.path.expanduser("~")
    paths = []
    if 'windows' in system:
        appdata = os.getenv('APPDATA')
        if appdata:
            paths.append(os.path.join(appdata, '.minecraft', 'mods'))
    elif 'darwin' in system:
        paths.append(os.path.join(home_dir, 'Library', 'Application Support', 'minecraft', 'mods'))
    elif 'linux' in system:
        paths.append(os.path.join(home_dir, '.minecraft', 'mods'))
    return paths

def is_valid_mods_folder(folder_path: str) -> bool:
    try:
        if not os.path.exists(folder_path) or not os.path.isdir(folder_path):
            return False
        jar_files = [f for f in os.listdir(folder_path) if f.lower().endswith('.jar')]
        return len(jar_files) > 0
    except Exception:
        return False

def get_folder_path_from_user(ui_lang: str) -> str:
    while True:
        hr()
        print(ui_get(ui_lang, "enter_mods_path"))
        hr()
        folder_path = input(ui_get(ui_lang, "path")).strip()

        if folder_path.lower() == 'help':
            print(ui_get(ui_lang, "common_paths"))
            for i, p in enumerate(get_common_minecraft_paths(), 1):
                print(f"  {i}. {p}")
            print(ui_get(ui_lang, "press_help_tip"))
            continue

        if is_valid_mods_folder(folder_path):
            jar_count = len([f for f in os.listdir(folder_path) if f.lower().endswith('.jar')])
            print(f"‚úÖ {jar_count} .jar")
            return folder_path

        print(ui_get(ui_lang, "path_invalid"))
        retry = input(ui_get(ui_lang, "retry")).strip().lower()
        if retry and retry in ['n', 'no']:
            sys.exit(0)

def confirm_folder_path(ui_lang: str, folder_path: str) -> bool:
    hr()
    print(f"{ui_get(ui_lang, 'folder')} {folder_path}")
    while True:
        confirm = input(ui_get(ui_lang, "confirm_folder")).strip().lower()
        if not confirm or confirm in ['y', 'yes']:
            return True
        if confirm in ['n', 'no']:
            return False

# =========================
# Language selection
# =========================
def choose_language(ui_lang: str, title_key: str, default_lang_code: str) -> str:
    hr()
    print(ui_get(ui_lang, title_key))
    hr()

    language_list = list(LANGUAGE_INFO.keys())
    for i, code in enumerate(language_list, 1):
        info = LANGUAGE_INFO[code]
        print(f"  {i}. {info['name']} ({code})")

    default_idx = language_list.index(default_lang_code) + 1 if default_lang_code in language_list else 1
    while True:
        raw = input(ui_get(ui_lang, "choose_range").format(n=len(language_list), d=str(default_idx))).strip()
        if not raw:
            return default_lang_code if default_lang_code in language_list else language_list[0]
        try:
            idx = int(raw) - 1
            if 0 <= idx < len(language_list):
                return language_list[idx]
        except ValueError:
            pass
        print(ui_get(ui_lang, "choose_invalid"))

def select_backup_option(ui_lang: str) -> str:
    hr()
    print(ui_get(ui_lang, "backup_menu"))
    hr()
    print("  " + ui_get(ui_lang, "backup_keep"))
    print("  " + ui_get(ui_lang, "backup_delete_success"))
    print("  " + ui_get(ui_lang, "backup_delete_all"))
    while True:
        raw = input(ui_get(ui_lang, "choose_range").format(n=3, d="1")).strip()
        if not raw or raw == "1":
            return "keep"
        if raw == "2":
            return "delete_success"
        if raw == "3":
            return "delete_all"
        print(ui_get(ui_lang, "choose_invalid"))

# =========================
# Jar operations
# =========================
def get_jar_files(folder_path: str):
    return [Path(os.path.join(folder_path, f)) for f in os.listdir(folder_path) if f.lower().endswith('.jar')]

def create_backup(ui_lang: str, jar_path: Path) -> str:
    backup_path = str(jar_path) + '.backup'
    if not os.path.exists(backup_path):
        print(f"  {ui_get(ui_lang, 'backup_created')} {os.path.basename(backup_path)}")
        shutil.copy2(jar_path, backup_path)
    else:
        print(f"  {ui_get(ui_lang, 'backup_exists')} {os.path.basename(backup_path)}")
    return backup_path

def delete_backup(ui_lang: str, backup_path: str) -> bool:
    try:
        if os.path.exists(backup_path):
            os.remove(backup_path)
            print(f"  {ui_get(ui_lang, 'delete_backup_ok')} {os.path.basename(backup_path)}")
            return True
        return False
    except Exception as e:
        print(f"  {ui_get(ui_lang, 'delete_backup_fail')} {str(e)}")
        return False

def find_lang_directories(root_dir: str):
    lang_dirs = []
    for root, dirs, _ in os.walk(root_dir):
        if 'lang' in dirs:
            lang_dirs.append(Path(root) / 'lang')
    return lang_dirs

def repackage_jar(source_dir: str, output_path: str):
    with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as jar:
        for root, _, files in os.walk(source_dir):
            for file in files:
                file_path = Path(root) / file
                relative_path = file_path.relative_to(source_dir)
                if '__MACOSX' in str(relative_path) or '.DS_Store' in str(relative_path):
                    continue
                jar.write(file_path, str(relative_path))

# =========================
# Translation
# =========================
def protect_formatting(text):
    """
    Replaces Minecraft formatting codes and Python format strings with placeholders
    to prevent Google Translate from mangling them.
    """
    placeholders = {}
    
    # Regex for:
    # 1. Minecraft color codes (e.g., ¬ßa, ¬ß1)
    # 2. Python/Java format strings (e.g., %s, %d, %1$s)
    # 3. Brace format strings (e.g., {0}, {name})
    pattern = re.compile(r'(¬ß[0-9a-fk-or]|%[0-9]*\$?[sd]|%[sd]|\{[a-zA-Z0-9_]+\})')
    
    def replace_match(match):
        key = f"__FMT{len(placeholders)}__"
        placeholders[key] = match.group(0)
        return key

    protected_text = pattern.sub(replace_match, text)
    return protected_text, placeholders

def restore_formatting(text, placeholders):
    """
    Restores the placeholders with original formatting codes.
    """
    for key, value in placeholders.items():
        # Use replace instead of regex to avoid issues if value contains regex chars
        text = text.replace(key, value)
        # Also handle cases where Google might have added spaces (e.g., __ FMT0 __)
        key_spaced = key.replace("__", "__ ") # Just in case, though usually it keeps it
        # A more robust regex for restoration if needed, but simple replace is safer for now
    
    # Fix common Google Translate artifacts on placeholders if they got spaced out
    # e.g. "__ FMT0 __" -> "__FMT0__"
    text = re.sub(r'__\s*FMT(\d+)\s*__', r'__FMT\1__', text)
    
    for key, value in placeholders.items():
        text = text.replace(key, value)
        
    return text

def google_translate(ui_lang: str, text, source_lang='en', target_lang='zh-TW'):
    if text is None:
        return text
    text = str(text)
    if not text.strip():
        return text

    # Protect formatting
    text_protected, placeholders = protect_formatting(text)

    cache_key = f"{source_lang}:{target_lang}:{text_protected}"
    if cache_key in translation_cache:
        return restore_formatting(translation_cache[cache_key], placeholders)

    try:
        encoded_text = quote(text_protected)
        url = f'https://translate.googleapis.com/translate_a/single?client=gtx&sl={source_lang}&tl={target_lang}&dt=t&q={encoded_text}'
        headers = {'User-Agent': 'Mozilla/5.0'}
        r = requests.get(url, headers=headers, timeout=15)
        r.raise_for_status()

        # parse a very simple pattern
        match = re.search(r'\[\["(.*?)",', r.text)
        if match:
            result = match.group(1).replace('\\"', '"').replace('\\n', '\n').replace('\\t', '\t')
            translation_cache[cache_key] = result
            return restore_formatting(result, placeholders)
    except Exception as e:
        if "429" in str(e) or "Too Many Requests" in str(e):
            print(f"  {ui_get(ui_lang, 'throttled')} {text[:30]}...")
        else:
            print(f"  {ui_get(ui_lang, 'trans_err')} {str(e)}")

    # Fallback uses original text, but we should try to preserve formatting there too if possible
    # But fallback_translation logic is regex based on words.
    return fallback_translation(text, target_lang.replace("-", "_").lower())

def fallback_translation(text: str, target_lang: str) -> str:
    if text is None:
        return text
    text = str(text)
    if not text.strip():
        return text

    # Don't strip color codes completely, just ignore them for matching if possible.
    # But for simple replacement, we can just iterate.
    
    result = text

    if target_lang in TERMINOLOGY:
        terminology = TERMINOLOGY[target_lang]
        # Sort keys by length descending to match longest phrases first
        sorted_keys = sorted(terminology.keys(), key=len, reverse=True)
        
        for eng in sorted_keys:
            trans = terminology[eng]
            # Use word boundary \b to avoid replacing parts of words (e.g. "Stone" in "Stonebrick")
            # But we need to be careful about color codes.
            # Simple regex replacement:
            result = re.sub(rf'\b{re.escape(eng)}\b', trans, result, flags=re.IGNORECASE)

    if result == text and target_lang != "en_us":
        # Only add prefix if absolutely no change and it's not just symbols
        if re.search(r'[a-zA-Z]', text):
            lang_prefix = LANGUAGE_INFO.get(target_lang, {}).get("name", target_lang)
            result = f"[{lang_prefix}] {text}"

    return result

def process_lang_directory(ui_lang: str, lang_dir: Path, target_lang: str):
    lang_info = LANGUAGE_INFO.get(target_lang, LANGUAGE_INFO["zh_tw"])
    en_us_file = lang_dir / 'en_us.json'
    target_lang_file = lang_dir / f'{target_lang}.json'

    if target_lang_file.exists():
        return False, f"exists ({target_lang}.json)"
    if not en_us_file.exists():
        return False, "missing en_us.json"

    try:
        en_data = json.loads(en_us_file.read_text(encoding='utf-8', errors='ignore'))

        target_data = {
            "language": lang_info['name'],
            "language.code": lang_info['code'],
            "language.region": lang_info['region']
        }

        total = len(en_data)
        with tqdm(total=total, desc=f"  üåê {lang_info['name']}", unit="item",
                  bar_format="{l_bar}{bar}| {n_fmt}/{total_fmt} [{elapsed}<{remaining}]") as pbar:
            for key, value in en_data.items():
                if key in ["language", "language.code", "language.region"]:
                    continue

                google_target = target_lang.replace('_', '-') if target_lang != "zh_tw" else "zh-TW"
                if google_target.lower() == "zh-cn":
                    google_target = "zh-CN"

                translated = google_translate(ui_lang, value, 'en', google_target)
                target_data[key] = translated
                pbar.update(1)

        target_lang_file.write_text(json.dumps(target_data, ensure_ascii=False, indent=2), encoding='utf-8')
        return True, "ok"

    except Exception as e:
        return False, f"error: {e}"

def process_single_mod(ui_lang: str, jar_path: Path, target_lang: str):
    hr()
    print(f"{ui_get(ui_lang, 'translate_mod')} {jar_path.name}")
    hr()

    backup_path = create_backup(ui_lang, jar_path)

    with tempfile.TemporaryDirectory() as temp_dir:
        try:
            with zipfile.ZipFile(jar_path, 'r') as jar:
                jar.extractall(temp_dir)

            lang_dirs = find_lang_directories(temp_dir)
            if not lang_dirs:
                return False, backup_path, ui_get(ui_lang, "no_lang_dir")

            processed_any = False
            messages = []

            for lang_dir in lang_dirs:
                result, msg = process_lang_directory(ui_lang, Path(lang_dir), target_lang)
                if result:
                    processed_any = True
                messages.append(f"- {Path(lang_dir).relative_to(temp_dir)}: {msg}")

            if not processed_any:
                return False, backup_path, "\n".join(messages)

            temp_jar_path = os.path.join(tempfile.gettempdir(), f"temp_{jar_path.name}")
            repackage_jar(temp_dir, temp_jar_path)
            shutil.move(temp_jar_path, jar_path)
            return True, backup_path, "\n".join(messages)

        except Exception as e:
            return False, backup_path, f"error: {str(e)}"

def scan_mods_for_translation(ui_lang: str, folder_path: str, target_lang: str):
    jar_files = get_jar_files(folder_path)
    mods_to_translate = []
    mods_skipped = []

    print("\n" + ui_get(ui_lang, "scan"))

    for jar_path in tqdm(jar_files, desc=ui_get(ui_lang, "scan_progress"), unit="mod"):
        try:
            with tempfile.TemporaryDirectory() as temp_dir:
                with zipfile.ZipFile(jar_path, 'r') as jar:
                    jar.extractall(temp_dir)

                lang_dirs = find_lang_directories(temp_dir)
                needs_translation = False
                reasons = []

                for lang_dir in lang_dirs:
                    target_lang_file = Path(lang_dir) / f'{target_lang}.json'
                    en_us_file = Path(lang_dir) / 'en_us.json'

                    if target_lang_file.exists():
                        reasons.append(f"{Path(lang_dir).relative_to(temp_dir)}: exists")
                    elif not en_us_file.exists():
                        reasons.append(f"{Path(lang_dir).relative_to(temp_dir)}: missing en_us.json")
                    else:
                        needs_translation = True

                if needs_translation:
                    mods_to_translate.append(jar_path)
                else:
                    mods_skipped.append((jar_path, ", ".join(reasons) if reasons else "no lang"))

        except Exception as e:
            mods_skipped.append((jar_path, f"scan error: {str(e)}"))

    return mods_to_translate, mods_skipped

def process_mods_folder(ui_lang: str, folder_path: str, target_lang: str, backup_option: str):
    mods_to_translate, mods_skipped = scan_mods_for_translation(ui_lang, folder_path, target_lang)

    if not mods_to_translate:
        print("\n" + ui_get(ui_lang, "no_need"))
        if mods_skipped:
            print(f"{ui_get(ui_lang, 'skipped')}: {len(mods_skipped)}")
        return 0, 0, []

    lang_name = LANGUAGE_INFO.get(target_lang, LANGUAGE_INFO["zh_tw"])["name"]
    print("\n" + ui_get(ui_lang, "found_need").format(n=len(mods_to_translate), lang=lang_name))
    for i, jar_path in enumerate(mods_to_translate[:10], 1):
        print(f"  {i}. {jar_path.name}")
    if len(mods_to_translate) > 10:
        print(f"  ... +{len(mods_to_translate) - 10}")

    confirm = input(ui_get(ui_lang, "confirm_translate").format(n=len(mods_to_translate), lang=lang_name)).strip().lower()
    if confirm and confirm not in ['y', 'yes']:
        print(ui_get(ui_lang, "cancel"))
        return 0, 0, []

    processed_count = 0
    failed_count = 0
    backup_info = []

    for i, jar_path in enumerate(mods_to_translate, 1):
        print(f"\n[{i}/{len(mods_to_translate)}] {jar_path.name}")
        success, backup_path, message = process_single_mod(ui_lang, jar_path, target_lang)
        backup_info.append((jar_path, backup_path, success))

        if success:
            processed_count += 1
        else:
            failed_count += 1
            print(f"  {ui_get(ui_lang, 'fail')} {message}")

    # backup deletion
    if backup_option != "keep":
        deleted = 0
        for _, backup_path, success in backup_info:
            should_delete = (backup_option == "delete_all") or (backup_option == "delete_success" and success)
            if should_delete:
                if delete_backup(ui_lang, backup_path):
                    deleted += 1
        print(f"{ui_get(ui_lang, 'deleted_backups')} {deleted}")

    return processed_count, failed_count, backup_info

def print_banner(ui_lang: str):
    title = ui_get(ui_lang, "banner_title")
    print("\n" +
          "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n" +
          f"‚ïë {title.center(77)} ‚ïë\n" +
          "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n")
    print(ui_get(ui_lang, "desc"))

def main():
    # 0) UI language first (bootstrap uses English UI strings, but selection list is multilingual names)
    ui_lang = choose_language("en_us", "choose_ui", default_lang_code="zh_tw")

    # 1) install packages
    if not install_required_packages(ui_lang):
        sys.exit(1)

    # 2) banner
    print_banner(ui_lang)

    # 3) target language (default = UI language)
    target_lang = choose_language(ui_lang, "choose_target", default_lang_code=ui_lang)

    # 4) backup option
    backup_option = select_backup_option(ui_lang)

    # 5) folder path
    folder_path = get_folder_path_from_user(ui_lang)
    if not confirm_folder_path(ui_lang, folder_path):
        print(ui_get(ui_lang, "cancel"))
        sys.exit(0)

    # 6) run
    try:
        processed_count, failed_count, _ = process_mods_folder(ui_lang, folder_path, target_lang, backup_option)

        lang_name = LANGUAGE_INFO.get(target_lang, LANGUAGE_INFO["zh_tw"])["name"]
        hr()
        print(ui_get(ui_lang, "summary"))
        hr()
        print(f"{ui_get(ui_lang,'ok')} {processed_count}")
        print(f"{ui_get(ui_lang,'fail')} {failed_count}")
        print(f"{ui_get(ui_lang,'folder')} {folder_path}")
        print(f"{ui_get(ui_lang,'target_lang')} {lang_name} ({target_lang})")
        print(f"{ui_get(ui_lang,'backup_policy')} {backup_option}")

    except KeyboardInterrupt:
        print("\n" + ui_get(ui_lang, "cancel"))
    except Exception as e:
        print(f"\n‚ùå error: {str(e)}")
        import traceback
        traceback.print_exc()

    print("\n" + ui_get(ui_lang, "done"))
    print("¬©coding master.2025/12/26")

if __name__ == "__main__":
    main()
